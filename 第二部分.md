# 使用 JWT 进行身份校验
在前面几节中，我们已经基本的完成了 `API’s` 的编写，但是，还存在一些非常严重的问题，例如，我们现在的` API `是可以随意调用的，这显然还不安全全，在本文中我们通过` jwt-go （GoDoc）`的方式来简单解决这个问题。

## jwt知识点补充
[jwt官网](https://jwt.io/)
### 认识JWT 
`JSON Web Token`（**JWT**）是一个开放标准（`RFC 7519`），它定义了一种紧凑和自包含的方式，用于在各方之间作为JSON对象安全地传输信息。

作为标准，它没有提供技术实现，但是大部分的语言平台都有按照它规定的内容提供了自己的技术实现，所以实际在用的时候，只要根据自己当前项目的技术平台，到**官网上选用合适的实现库**即可。

### TOKEN是什么
`Token`，其实就是服务端生成的一串**加密字符串**、以作客户端进行请求的一个“令牌”

![Alt text](token.png)

### jwt的使用场景
以下是JWT两种使用场景：

>**授权**：这是使用` JWT` 的最常见的使用场景。用户登录后，每个后续请求都将包含 `JWT`，允许用户访问使用该令牌允许的路由、服务和资源。**单点登录**是当今广泛使用 `JWT` 的一项功能，因为它的开销很小，并且能够跨不同域轻松使用。

>**信息交换**：`JWT`是在各方之间安全传输信息的比较便捷的方式。由于 `JWT` 可以签名（例如，使用`公钥`/`私钥`对），因此可以确定发送者是否是在您的授权范围之内。并且，由于签名是使用标头和有效负载计算的，因此还可以**验证内容是否未被篡改**。

### jwt的组成
这是一个JWT的token串：
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```
其实这一串是经过加密之后的密文字符串，中间通过`.`来分割。每个`.`之前的字符串分别表示`JWT`的三个组成部分：`Header`、`Payload`、`Signature`。
#### header
Header的主要作用是用来标识,通常是**两部分组成**：
>`typ`：`type` 的简写，令牌类型，也就是`JWT`。

>`alg`：`Algorithm` 的简写，加密签名算法。一般使用`HS256`，`jwt`官网提供了12种的加密算法

然后通过base64编码，将明文编码,防止在传输过程中能直接一眼看出明文并符合多种传输协议

#### payload
也称为`JWT claims`

`payload`用来承载要传递的数据，它的`json`结构实际上是对`JWT`要传递的数据的一组声明，这些声明被`JWT`标准称为`claims`，它的一个“**属性值对**”其实就是一个`claim`，每一个`claim`的都代表特定的含义和作用

claims有三类：

- **保留claims**：主要包括`iss`发行者、`exp`过期时间、`sub`主题、`aud`用户等。

key|name|说明
-|-|-
iss|发送者|	标识颁发 `JWT` 的发送主体
sub|	主题|	标识 `JWT` 的主题
aud|	接收者|标识 `JWT` 所针对的接收者。每个在处理 `JWT `的主体都必须使用受众声明中的值来标识自己。如果处理的主体在存在此声明时未将自己标识为声明中的值，则必须拒绝` JWT`
exp|到期时间|	标识不得接受 `JWT` 进行处理的过期时间。该值必须是日期类型，而且是`1970-01-01 00：00：00Z` 之后的日期秒。
nbf|	`jwt`的开始处理的时间|	标识 `JWT `开始接受处理的时间。该值必须是日期。
iat|	`jwt`发出的时间|标识 `JWT` 的发出的时间。该值必须是日期。
jti|	jwt id|令牌的区分大小写的唯一标识符，即使在不同的颁发者之间也是如此。

保留`claim`为`jwt`标准中规定的`claim`，验证方式已经定义好
- **公共claims**：定义新创的信息，比如用户信息和其他重要信息。(使用较少)
- **私有claims**：用于发布者和消费者都同意以私有的方式使用的信息。

明文实例：
```
{
  "sub": "12344321",
  "name": "Mars酱", // 私有claims
  "iat": 1516239022
}
```

base64加密后：
```
eyJzdWIiOiIxMjM0NDMyMSIsIm5hbWUiOiJNYXJz6YWxIiwiaWF0IjoxNTE2MjM5MDIyfQ
```


#### signature
`Signature `部分是对`Header`和`Payload`两部分的签名，作用是**防止 `JWT `被篡改**。这个部分的生成规则主要是是公式（伪代码）是：
```
Header中定义的签名算法alg(
    base64编码(header) + "." + base64编码(payload),
    secret//在服务端加密使用的密钥
)
```

`JWT`如果从字面上理解感觉是基于`JSON`格式用于**网络传输**的**令牌**。实际上，`JWT`是一种紧凑的`Claims`声明格式，，常见的场景如HTTP授权请求头参数和URI查询参数。`JWT`会把`Claims`转换成`JSON`格式，而这个`JSON`内容将会应用为`JWS`结构的有效载荷或者应用为`JWE`结构的（加密处理后的）原始字符串，通过消息认证码（`Message Authentication Code`或者简称`MAC`）和/或者加密操作对`Claims`进行数字签名或者完整性保护。


## 下载依赖包
```shell
go get -u github.com/dgrijalva/jwt-go
```
## 编写 jwt 工具包
我们需要编写一个`jwt`的工具包，我们在`pkg`下的`util`目录新建`jwt.go`，写入文件内容:
```go
package util

import (
	"time"

	jwt "github.com/dgrijalva/jwt-go"

	"github.com/kingsill/gin-example/pkg/setting"
)

// 加载配置文件中设置的密钥
var jwtSecret = []byte(setting.JwtSecret)

// Claims 定义claims结构体
type Claims struct {
	Username string `json:"username"`
	Password string `json:"password"`
	jwt.StandardClaims
}

func GenerateToken(username, password string) (string, error) {
	nowTime := time.Now()
	expireTime := nowTime.Add(3 * time.Hour)

	//创建 CustomClaims 结构体，用来封装 jwt 信息
	claims := Claims{
		username,
		password,
		jwt.StandardClaims{
			ExpiresAt: expireTime.Unix(),
			Issuer:    "gin-blog",
		},
	}

	//创建 header和payload部分
	tokenClaims := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	//得到完整的token字符串，这里为加入签名signature部分
	token, err := tokenClaims.SignedString(jwtSecret)

	return token, err
}

func ParseToken(token string) (*Claims, error) {
	//解码过程
	tokenClaims, err := jwt.ParseWithClaims(token, &Claims{}, func(token *jwt.Token) (interface{}, error) {
		return jwtSecret, nil
	})

	//验证是否时间过期
	if tokenClaims != nil {
		if claims, ok := tokenClaims.Claims.(*Claims); ok && tokenClaims.Valid {
			return claims, nil
		}
	}

	return nil, err
}

```