# 知识点
- 信号量的了解
- 应用热更新

# 本节目标
在前文中，我们在配置玩之后直接使用 `ctrl+c` 来进行进程的结束，我们将了解 `ctrl+c` 的过程中到底进行了什么
简单讲述 `ctrl+c` 背后的**信号** 以及如何在`gin` 中**优雅的重启服务**，也就是对HTTP服务进行热更新
## 何谓优雅
- 不关闭现有连接（正在运行中的程序）
- 新的进程启动并替代旧进程
- 新的进程接管新的连接
- 连接要随时相应用户的请求，当用户仍在请求旧进程时要保持连接，新用户应请求新进程，不可以出现拒绝请求的情况



# ctrl+c
>内核在某些情况下发送信号，比如在进程往一个已经关闭的管道写数据时会产生`SIGPIPE`信号
我们在执行`ctrl+c`关闭`gin`服务端时，会强制结束进程，导致正在访问的用户等出现问题

## 信号
**信号**是 `Unix` 、`类 Unix `以及其他` POSIX `兼容的操作系统中进程间通讯的一种有限制的方式

它是一种异步的通知机制，用来提醒进程一个事件（硬件异常、程序执行异常、外部发出信号）已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程。此时，任何非原子操作都将被中断。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数

# 修改流程
1. 替换可执行文件或修改配置文件
2. 发送信号量
3. 拒绝新连接请求旧进程，但要保证已有连接进程
4. 去启动新的子进程
5. 新的子进程开始accept
6. 系统将新的请求转交新的子进程
7. 旧进程处理玩所有旧连接后正常结束

# 实现优雅重启
我们借助` fvbock/endless` 来实现 `Golang HTTP/HTTPS` 服务重新启动的零停机
## endless
借助 [fvbock/endless](https://github.com/fvbock/endless) 来实现 `Golang HTTP/HTTPS `服务重新启动的零停机

`endless server`监听以下几种信号量：
- `syscall.SIGHUP`：触发 fork 子进程和重新启动
- `syscall.SIGUSR1/syscall.SIGTSTP`：被监听，但不会触发任何动作
- `syscall.SIGUSR2`：触发 hammerTime
- `syscall.SIGINT/syscall.SIGTERM`：触发服务器关闭（会完成正在运行的请求）

### 安装 
```
go get -u github.com/fvbock/endless
```
## 编写
打开 `gin-blog` 的 `main.go`文件，修改文件：